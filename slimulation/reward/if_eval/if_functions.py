# from https://github.com/allenai/open-instruct/blob/main/open_instruct/if_functions.py
# Thanks to Olmo and OpenInstruct

import json
import re

"""
This module contains functions to verify constraints in the responses generated by the model.
It covers all 25 constraints from the IFEval taxonomy. To be used either for eval or for ground truth rewards.
"""


# include keywords: Include keywords {keyword1}, {keyword2} in your response
def verify_keywords(text, keyword_list):
    """
    Verify if the response contains all the specified keywords.

    Args:
        response (str): The response text to check
        keyword_list (list): A list of keywords to check for

    Returns:
        bool: True if all keywords are present in the response, False otherwise
    """
    # Convert response to lowercase for case-insensitive matching
    response_lower = text.lower()

    # Check if all keywords are present in the response
    return all(keyword.lower() in response_lower for keyword in keyword_list)


# Keyword Frequency: In your response, the word {word} should appear {N} times.
def verify_keyword_frequency(text, word, N):
    """
    Verifies if a keyword appears exactly N times in the given text.

    Args:
        text (str): The text to analyze
        keyword (str): The keyword to count
        expected_count (int): The expected number of occurrences

    Returns:
        tuple: (bool, int) - (Whether constraint is met, actual count found)
    """
    # Convert text to lowercase to make the search case-insensitive
    text = text.lower()
    keyword = word.lower()

    # Split text into words and remove punctuation
    import re

    words = re.findall(r"\b\w+\b", text)

    # Count actual occurrences
    actual_count = sum(1 for word in words if word == keyword)

    # Check if constraint is met
    constraint_met = actual_count == N

    return constraint_met


# Forbidden Words: Do not include keywords {forbidden words} in the response.
def validate_forbidden_words(text, forbidden_words):
    """
    Validates that the text does not contain any of the specified forbidden words.

    Args:
        text (str): The text to check for forbidden words
        forbidden_words (list[str]): A list of forbidden words

    Returns:
        tuple[bool, list[str]]: A tuple containing:
            - Boolean indicating if any forbidden words are present
            - List of forbidden words found in the text

    Example:
        text = "This is a message that should not contain any bad words"
        forbidden_words = ["bad", "evil", "harmful"]
        result = validate_forbidden_words(text, forbidden_words)
    """
    # Convert text to lowercase for case-insensitive matching
    text_lower = text.lower()

    # Check each forbidden word
    found_words = [word for word in forbidden_words if word.lower() in text_lower]

    # Return results
    return len(found_words) == 0


# Letter Frequency : In your response, the letter {letter} should appear {N} times.


def verify_letter_frequency(text: str, letter: str, N: int) -> bool:
    """
    Verifies if a given letter appears exactly the specified number of times in the text.

    Args:
        text (str): The text to check
        letter (str): The letter to count (case-sensitive)
        target_count (int): The expected number of occurrences

    Returns:
        bool: True if the constraint is met, False otherwise

    Example:
        >>> verify_letter_frequency("hello world", "l", 3)
        True
        >>> verify_letter_frequency("hello world", "o", 2)
        True
        >>> verify_letter_frequency("hello world", "x", 0)
        True
    """
    if len(letter) != 1:
        raise ValueError("Letter parameter must be a single character")

    actual_count = text.count(letter)
    return actual_count == N


# Response Language: Your ENTIRE response should be in {language}, no other language is allowed.


def validate_response_language(text, language):
    """
    Validates that the entire response is in the specified language.

    Args:
        text (str): The text to check
        language (str): The language code (e.g., 'en' for English)

    Returns:
        bool: True if the response is entirely in the specified language, False otherwise

    Example:
        text = "This is an English sentence"
        language = "en"
        result = validate_response_language(text, language)
    """
    from langdetect import detect

    # Detect the language of the text
    detected_language = detect(text)
    # Check if the detected language matches the expected language
    return detected_language == language


# Number Paragraphs: Your response should contain {N} paragraphs. You separate paragraphs using the markdown divider:
# * * *
def verify_paragraph_count(text: str, N: int) -> bool:
    """
    Verifies that a text contains the expected number of paragraphs,
    where paragraphs are separated by markdown dividers '* * *'

    Args:
        text (str): The text to analyze
        expected_count (int): Expected number of paragraphs

    Returns:
        bool: True if the text contains exactly the expected number of paragraphs,
              False otherwise

    Example:
         text = "First paragraph\n* * *\nSecond paragraph"
         verify_paragraph_count(text, 2)
        True
    """

    def clean_text(text: str) -> str:
        """Remove extra whitespace and normalize line endings"""
        return "\n".join(line.strip() for line in text.splitlines()).strip()

    # Clean the input text
    text = clean_text(text)

    # Split text by markdown divider
    # Add 1 to count since n dividers create n+1 paragraphs
    paragraphs = text.split("* * *")
    actual_count = len(paragraphs)

    # Verify each split resulted in non-empty content
    valid_paragraphs = [p.strip() for p in paragraphs if p.strip()]
    if len(valid_paragraphs) != actual_count:
        return False

    return actual_count == N


# Number Words: Answer with at least / around / at most {N} words


def validate_word_constraint(text: str, N: int, quantifier: str) -> bool:
    """
    Validates if a text meets specified word count constraints.

    Args:
        text (str): The text to check
        count (int): The target word count
        qualifier (str): The type of constraint ('at least', 'around', 'at most')

    Returns:
        bool: True if the constraint is met, False otherwise

    Raises:
        ValueError: If an invalid qualifier is provided
    """
    # Remove extra whitespace and split into words
    words = text.strip().split()
    actual_count = len(words)

    # Define tolerance for "around" qualifier (Â±10% of target count)
    tolerance = max(round(N * 0.1), 1)

    if quantifier == "at least":
        return actual_count >= N
    elif quantifier == "at most":
        return actual_count <= N
    elif quantifier == "around":
        return abs(actual_count - N) <= tolerance
    else:
        return False


# Number Sentences: Answer with at least / around / at most {N} sentences.
def verify_sentence_constraint(text: str, N: int, quantifier: str) -> bool:
    """
    Verifies if a text contains the expected number of sentences.

    Args:
        text (str): The text to analyze
        N (int): The expected number of sentences
        quantifier (str): The quantifier ('at least', 'around', 'at most')

    Returns:
        bool: True if the text contains the expected number of sentences, False otherwise
    """
    # Split the text into sentences
    sentences = re.split(r"(?<!\w\.\w.)(?<![A-Z][a-z]\.)(?<=\.|\?)\s", text)

    # Count the number of sentences
    actual_count = len(sentences)

    # Check if the actual count matches the expected count based on the quantifier
    if quantifier == "at least":
        return actual_count >= N
    elif quantifier == "around":
        return abs(actual_count - N) <= 1
    elif quantifier == "at most":
        return actual_count <= N
    else:
        return False


# Number Paragraphs + First Word in i-th Paragraph: There should be {N} paragraphs. Paragraphs and only paragraphs
# are separated with each other by two line breaks. The {i}-th paragraph must start with word {first word}.
def validate_paragraphs(text, N, first_word, i):
    """
    Validates that a text contains the expected number of paragraphs and that the i-th paragraph starts with a specific
    word.

    Args:
        text (str): The text to analyze
        N (int): The expected number of paragraphs
        first_word (str): The expected first word of the i-th paragraph
        i (int): The index of the paragraph to check (1-indexed)

    Returns:
        bool: True if the text meets the paragraph and first word requirements, False otherwise
    """
    # Split the text into paragraphs
    paragraphs = text.split("\n\n")

    # Check if the number of paragraphs is as expected
    if len(paragraphs) != N:
        return False

    # Check if the i-th paragraph starts with the specified first word
    return bool(paragraphs[i - 1].strip().startswith(first_word))


# Postscript: At the end of your response, please explicitly add a postscript starting with {postscript marker}


def verify_postscript(text, postscript_marker):
    """
    Verifies if a text contains a postscript starting with '{postscript marker}'

    Args:
        text (str): The text to verify

    Returns:
        bool: True if the text contains a valid postscript, False otherwise
    """
    # Check if the text contains the postscript marker
    if postscript_marker in text:
        # Get the index of the marker
        marker_index = text.find(postscript_marker)
        # Check if the marker appears near the end
        remaining_text = text[marker_index:].strip()
        # Verify it's not just the marker alone
        return len(remaining_text) > len(postscript_marker)
    return False


# Number Placeholder: The response must contain at least {N} placeholders represented by square brackets,
# such as [address].
def validate_placeholders(text: str, N: int) -> tuple[bool, list[str]]:
    """
    Validates if a text contains at least the specified number of placeholders in square brackets.

    Args:
        text (str): The text to check for placeholders
        min_placeholders (int): Minimum number of placeholders required

    Returns:
        tuple[bool, List[str]]: A tuple containing:
            - Boolean indicating if the text meets the placeholder requirement
            - List of found placeholders

    Example:
        >>> text = "Hello [name], your [item] will be delivered to [address]"
        >>> validate_placeholders(text, 2)
        (True, ['name', 'item', 'address'])
    """
    # Find all placeholders using regex
    pattern = r"\[(.*?)\]"
    placeholders = re.findall(pattern, text)

    # Check if the number of placeholders meets the requirement
    has_enough = len(placeholders) >= N

    return has_enough


# Number Bullets: Your answer must contain exactly {N} bullet points. Use the markdown bullet points such as: * This
# is a point.
def verify_bullet_points(text: str, N: int) -> tuple[bool, str]:
    """
    Verifies if a text contains exactly N bullet points in markdown format.
    Returns a tuple of (is_valid, message).

    Args:
        text (str): The text to check
        expected_count (int): The expected number of bullet points

    Returns:
        tuple[bool, str]: (True if constraint is met, explanation message)
    """
    # Split text into lines and count lines starting with * or -
    lines = text.split("\n")
    bullet_points = [line.strip() for line in lines if line.strip().startswith(("*", "-"))]
    actual_count = len(bullet_points)

    return actual_count == N


# Title: Your answer must contain a title, wrapped in double angular brackets, such as <<poem of joy>>.
def validate_title(text: str) -> bool:
    pattern = r"<<(.*?)>>"
    matches = re.findall(pattern, text)

    return len(matches) > 0


# Choose: From Answer with one of the following options: {options}
def validate_choice(text: str, options: list) -> bool:
    return any(text in option for option in options)


# Minimum Number Highlighted Section: Highlight at least {N} sections in your answer with markdown, i.e. *highlighted
# section*
def validate_highlighted_sections(text: str, N: int) -> bool:
    pattern = r"\*(.*?)\*"
    matches = re.findall(pattern, text)

    return len(matches) >= N


# Multiple Sections: Your response must have {N} sections. Mark the beginning of each section with {section splitter} X.


def validate_sections(text: str, N: int, section_splitter: str) -> bool:
    sections = text.split(section_splitter)
    # The first section might not start with the splitter, so we adjust for this
    if sections[0] == "":
        sections.pop(0)
    return len(sections) == N


# JSON Format : Entire output should be wrapped in JSON format.
def validate_json_format(text: str) -> bool:
    try:
        json.loads(text)
    except ValueError:
        return False
    return True


# Repeat Prompt: First, repeat the request without change, then give your answer (do not say anything before
# repeating the request; the request you need to repeat does not include this sentence)
def validate_repeat_prompt(text: str, original_prompt: str) -> bool:
    return bool(text.startswith(original_prompt))


# Two Responses: Give two different responses. Responses and only responses should be separated by 6 asterisk
# symbols: ******.
def validate_two_responses(text: str) -> bool:
    if text.count("******") == 1:
        response_list = text.split("******")
        first_response = response_list[0].strip()
        second_response = response_list[1].strip()
        if first_response != second_response:
            return True
    return False


# All Uppercase: Your entire response should be in English, capital letters only.
def validate_uppercase(text: str) -> bool:
    # Check if the response is the same as the uppercase version of the response
    return text == text.upper()


# All Lowercase: Your entire response should be in English, and in all lowercase letters. No capital letters are
# allowed.
def validate_lowercase(text: str) -> bool:
    # Check if the response is the same as the lowercase version of the response
    return text == text.lower()


# Frequency of All-capital Words: In your response, words with all capital letters should appear at least / around /
# at most {N} times.
def validate_frequency_capital_words(text: str, N: int, quantifier: str) -> bool:
    words = re.findall(r"\b[A-Z]+\b", text)
    if quantifier == "at least":
        return len(words) >= N
    elif quantifier == "around":
        return len(words) == N
    elif quantifier == "at most":
        return len(words) <= N
    else:
        return False


# End Checker: Finish your response with this exact phrase {end phrase}. No other words should follow this phrase.
def validate_end(text: str, end_phrase: str) -> bool:
    # Check if the response ends with the end phrase
    return bool(text.endswith(end_phrase))


# Quotation: Wrap your entire response with double quotation marks.
def validate_quotation(text: str) -> bool:
    return bool(text.startswith('"') and text.endswith('"'))


# No Commas: In your entire response, refrain from the use of any commas.
def validate_no_commas(text: str) -> bool:
    return "," not in text


IF_FUNCTIONS_MAP = {
    "verify_keywords": verify_keywords,
    "verify_keyword_frequency": verify_keyword_frequency,
    "validate_forbidden_words": validate_forbidden_words,
    "verify_letter_frequency": verify_letter_frequency,
    "validate_response_language": validate_response_language,
    "verify_paragraph_count": verify_paragraph_count,
    "validate_word_constraint": validate_word_constraint,
    "verify_sentence_constraint": verify_sentence_constraint,
    "validate_paragraphs": validate_paragraphs,
    "verify_postscript": verify_postscript,
    "validate_placeholders": validate_placeholders,
    "verify_bullet_points": verify_bullet_points,
    "validate_title": validate_title,
    "validate_choice": validate_choice,
    "validate_highlighted_sections": validate_highlighted_sections,
    "validate_sections": validate_sections,
    "validate_json_format": validate_json_format,
    "validate_repeat_prompt": validate_repeat_prompt,
    "validate_two_responses": validate_two_responses,
    "validate_uppercase": validate_uppercase,
    "validate_lowercase": validate_lowercase,
    "validate_frequency_capital_words": validate_frequency_capital_words,
    "validate_end": validate_end,
    "validate_quotation": validate_quotation,
    "validate_no_commas": validate_no_commas,
}


if __name__ == "__main__":
    print("Testing all IFEval constraint functions...")

    # Test verify_keywords
    print("\n1. Testing verify_keywords:")
    text1 = "This response includes Python and programming keywords"
    keywords = ["python", "programming"]
    result1 = verify_keywords(text1, keywords)
    print(f"Text: '{text1}'")
    print(f"Keywords: {keywords}")
    print(f"Result: {result1} (Expected: True)")

    # Test verify_keyword_frequency
    print("\n2. Testing verify_keyword_frequency:")
    text2 = "The word hello appears hello three hello times in this sentence hello"
    result2 = verify_keyword_frequency(text2, "hello", 4)
    print(f"Text: '{text2}'")
    print(f"Word: 'hello', Expected count: 4")
    print(f"Result: {result2} (Expected: True)")

    # Test validate_forbidden_words
    print("\n3. Testing validate_forbidden_words:")
    text3 = "This is a clean message without bad words"
    forbidden = ["bad", "evil", "harmful"]
    result3 = validate_forbidden_words(text3, forbidden)
    print(f"Text: '{text3}'")
    print(f"Forbidden words: {forbidden}")
    print(f"Result: {result3} (Expected: True)")

    # Test verify_letter_frequency
    print("\n4. Testing verify_letter_frequency:")
    text4 = "Hello world"
    result4 = verify_letter_frequency(text4, "l", 3)
    print(f"Text: '{text4}'")
    print(f"Letter: 'l', Expected count: 3")
    print(f"Result: {result4} (Expected: True)")

    # Test validate_response_language
    # print("\n5. Testing validate_response_language:")
    # text5 = "This is an English sentence"
    # result5 = validate_response_language(text5, "en")
    # print(f"Text: '{text5}'")
    # print(f"Expected language: 'en'")
    # print(f"Result: {result5} (Expected: True)")

    # Test verify_paragraph_count
    print("\n6. Testing verify_paragraph_count:")
    text6 = "First paragraph\n* * *\nSecond paragraph\n* * *\nThird paragraph"
    result6 = verify_paragraph_count(text6, 3)
    print(f"Text: '{text6}'")
    print(f"Expected paragraphs: 3")
    print(f"Result: {result6} (Expected: True)")

    # Test validate_word_constraint
    print("\n7. Testing validate_word_constraint:")
    text7 = "This sentence has exactly five words"
    result7 = validate_word_constraint(text7, 5, "around")
    print(f"Text: '{text7}'")
    print(f"Word count constraint: around 5")
    print(f"Result: {result7} (Expected: True)")

    # Test verify_sentence_constraint
    print("\n8. Testing verify_sentence_constraint:")
    text8 = "This is the first sentence. This is the second sentence. This is the third."
    result8 = verify_sentence_constraint(text8, 3, "around")
    print(f"Text: '{text8}'")
    print(f"Sentence count constraint: around 3")
    print(f"Result: {result8} (Expected: True)")

    # Test validate_paragraphs
    print("\n9. Testing validate_paragraphs:")
    text9 = "First paragraph\n\nSecond paragraph\n\nThird paragraph"
    result9 = validate_paragraphs(text9, 3, "Second", 2)
    print(f"Text: '{text9}'")
    print(f"Expected paragraphs: 3, 2nd paragraph starts with 'Second'")
    print(f"Result: {result9} (Expected: True)")

    # Test verify_postscript
    print("\n10. Testing verify_postscript:")
    text10 = "This is the main response. P.S. This is a postscript"
    result10 = verify_postscript(text10, "P.S.")
    print(f"Text: '{text10}'")
    print(f"Postscript marker: 'P.S.'")
    print(f"Result: {result10} (Expected: True)")

    # Test validate_placeholders
    print("\n11. Testing validate_placeholders:")
    text11 = "Hello [name], your [item] will be delivered to [address]"
    result11 = validate_placeholders(text11, 2)
    print(f"Text: '{text11}'")
    print(f"Minimum placeholders: 2")
    print(f"Result: {result11} (Expected: True)")

    # Test verify_bullet_points
    print("\n12. Testing verify_bullet_points:")
    text12 = "* First point\n* Second point\n* Third point"
    result12 = verify_bullet_points(text12, 3)
    print(f"Text: '{text12}'")
    print(f"Expected bullet points: 3")
    print(f"Result: {result12} (Expected: True)")

    # Test validate_title
    print("\n13. Testing validate_title:")
    text13 = "<<My Title>> This is the content"
    result13 = validate_title(text13)
    print(f"Text: '{text13}'")
    print(f"Result: {result13} (Expected: True)")

    # Test validate_choice
    print("\n14. Testing validate_choice:")
    text14 = "Option A"
    options = ["Option A", "Option B", "Option C"]
    result14 = validate_choice(text14, options)
    print(f"Text: '{text14}'")
    print(f"Options: {options}")
    print(f"Result: {result14} (Expected: True)")

    # Test validate_highlighted_sections
    print("\n15. Testing validate_highlighted_sections:")
    text15 = "This is *highlighted* and this is also *emphasized*"
    result15 = validate_highlighted_sections(text15, 2)
    print(f"Text: '{text15}'")
    print(f"Minimum highlighted sections: 2")
    print(f"Result: {result15} (Expected: True)")

    # Test validate_sections
    print("\n16. Testing validate_sections:")
    text16 = "Section 1: Introduction\n---\nSection 2: Details\n---\nSection 3: Conclusion"
    result16 = validate_sections(text16, 3, "---")
    print(f"Text: '{text16}'")
    print(f"Expected sections: 3, Splitter: '---'")
    print(f"Result: {result16} (Expected: True)")

    # Test validate_json_format
    print("\n17. Testing validate_json_format:")
    text17 = '{"name": "John", "age": 30}'
    result17 = validate_json_format(text17)
    print(f"Text: '{text17}'")
    print(f"Result: {result17} (Expected: True)")

    # Test validate_repeat_prompt
    print("\n18. Testing validate_repeat_prompt:")
    original_prompt = "What is your name?"
    text18 = "What is your name? My name is John."
    result18 = validate_repeat_prompt(text18, original_prompt)
    print(f"Original prompt: '{original_prompt}'")
    print(f"Text: '{text18}'")
    print(f"Result: {result18} (Expected: True)")

    # Test validate_two_responses
    print("\n19. Testing validate_two_responses:")
    text19 = "First response\n******\nSecond response"
    result19 = validate_two_responses(text19)
    print(f"Text: '{text19}'")
    print(f"Result: {result19} (Expected: True)")

    # Test validate_uppercase
    print("\n20. Testing validate_uppercase:")
    text20 = "THIS IS ALL UPPERCASE TEXT"
    result20 = validate_uppercase(text20)
    print(f"Text: '{text20}'")
    print(f"Result: {result20} (Expected: True)")

    # Test validate_lowercase
    print("\n21. Testing validate_lowercase:")
    text21 = "this is all lowercase text"
    result21 = validate_lowercase(text21)
    print(f"Text: '{text21}'")
    print(f"Result: {result21} (Expected: True)")

    # Test validate_frequency_capital_words
    print("\n22. Testing validate_frequency_capital_words:")
    text22 = "The NASA project involves AI and ML technologies"
    result22 = validate_frequency_capital_words(text22, 3, "around")
    print(f"Text: '{text22}'")
    print(f"Expected capital words: around 3")
    print(f"Result: {result22} (Expected: True)")

    # Test validate_end
    print("\n23. Testing validate_end:")
    text23 = "This is a response. End of message."
    result23 = validate_end(text23, "End of message.")
    print(f"Text: '{text23}'")
    print(f"End phrase: 'End of message.'")
    print(f"Result: {result23} (Expected: True)")

    # Test validate_quotation
    print("\n24. Testing validate_quotation:")
    text24 = '"This entire response is quoted"'
    result24 = validate_quotation(text24)
    print(f"Text: '{text24}'")
    print(f"Result: {result24} (Expected: True)")

    # Test validate_no_commas
    print("\n25. Testing validate_no_commas:")
    text25 = "This response has no commas in it"
    result25 = validate_no_commas(text25)
    print(f"Text: '{text25}'")
    print(f"Result: {result25} (Expected: True)")

    print("\nAll tests completed!")